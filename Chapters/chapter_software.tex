%************************************************
\myChapter{Oprogramowanie}\label{ch:software}
%************************************************

Jako zwolennik wolnego i otwartego oprogramowania starałem się korzystać tylko i wyłącznie z takich właśnie narzędzi.

\graffito{ \includegraphics[width=\marginparwidth]{gfx/gnuhead_inkscape.pdf} Logo Fundacji Wolnego Oprogramowania \ppauza Free Software Foundation \citep{FSF}}Sama praca udostępniana jest na zasadach otwartej licencji \textsc{GNU GPL 3.0}. Wszystkie otwarte licencje typu \textsc{GNU GPL} stworzone zostały przez fundację FSF, która też stoi na straży ich przestrzegania.

Oprogramowanie stworzone na potrzeby pracy składa się z dwóch elementów:
\begin{itemize}
 \item oprogramowania na komputer,
 \item oprogramowania na mikrokontroler.\\
\end{itemize}

Większość zmian mikrokontrolera, opisywana w rozdziale \ref{ch:hardware}, pociągała za sobą przepisanie oprogramowania praktycznie od zera ze względu na rdzenie z kompletnie innych rodzin, inne dostępne moduły oraz inny sposób ich obsługi. Ilość tych zmian, a także dodatkowe utrudnienia pod postacią niedostępności debugowania, skomplikowanej instalacji słabo dostępnych i przestarzałych pakietów kompilatora skłoniły mnie do poszukania rozwiązania typu RTOS lub podobnego.
W taki sposób znalazłem środowisko \textsc{Energia}, \textit{fork} środowiska \textsc{Arduino}\graffito{Programy w środowisku \textsc{Arduino} noszą nazwę ,,sketch''.}, oparty o toolchain \textsc{msp-gcc} oraz \textsc{arm-gcc}, pozwalający pisać programy w języku C++ ukrywając wiele szczegółowych operacji przed programistą jak np. konfiguracja stosu USB, pozwalając mu skoncentrować się na istocie tworzonego programu.\\

\section{Protokół komunikacji}

Komunikacja hosta z mikrokontrolerem odbywa się przez wirtualny port szeregowy (urządzenie \textsc{USB Communications Device Class, CDC}). Narzuca to kilka ograniczeń dotyczących możliwości protokołu, które należy uwzględnić podczas jego projektowania:
\begin{itemize}
 \item mikrokontroler będzie widoczny jako zwykłe urządzenie znakowe, należy więc zadbać, aby przesyłane dane były w postaci czytelnej także w zwykłym kliencie terminala,
 \item sposób komunikacji musi uwzględniać możliwość synchronizacji, np. za pomocą specjalnego znaku, który nie pojawia się w innym przypadku,
 \item protokół musi być możliwie zwięzły ze względu na ograniczoną przepustowość łącza,
 \item komunikacja musi przebiegać dwukierunkowo (w trybie przynajmniej half-duplex).\\
\end{itemize}

Uwzględniając powyższe wytyczne, opracowałem protokół o następujących cechach:
\begin{itemize}
 \item Wszystkie przesyłane dane są pod postacią znaków kodu ASCII, zarówno z hosta do mikrokontrolera jak i z powrotem. Używane są trzy sposoby tłumaczenia danych z postaci binarnej na kod ASCII:
 \begin{enumerate}
  \item Numeryczny zapis dziesiętny \pauza wartości zapisywane są w~systemie dziesiętnym po jednej stronie, druga strona konwertuje liczbę ponownie na system binarny.
  \item Base64 \pauza System konwersji danych konwertujący ciąg 8-bitowych danych na ciąg 6-bitowych danych z określonym alfabetem.\graffito{\color{red}opisać w załączniku base64}
  \item Zapis binarny z offsetem \pauza dla ograniczonych wielkości zmiennych zastosowałem przesunięcie wartości, które zapewnia ich prezentację w kodzie ASCII: do wartości zmiennej dodawany jest offset 'a', tak więc 'a' rozumiane jest jako 0, 'b' jako 1, itd.
 \end{enumerate}
 \item Do synchronizacji wykorzystany został znak o kodzie \textsc{0x0D}, czyli powrót karetki (\textit{carriage return}), dzięki czemu synchronizacja jest czytelnia zarówno dla komputera jak i człowieka.
 \item Protokół został zaprojektowany w modulu klient-serwer, gdzie klient (komputer) odpytuje o dane serwer (mikrokontroler).\\
\end{itemize}

Dzięki identyfikowania urządzenia jako port szeregowy, możliwe jest podłączenie się dowolnym klientem terminala (np. \textsc{screen}, \textsc{minicom}, itp.) i ręczna obsługa urządzenia.
Znacznie pomaga to podczas rozwijania oprogramowania umożliwiając łatwe wprowadzenie systemu w~skrajne przypadki.\\

Obsługę protokołu od strony mikrokontrolera można przedstawić pseudokodem z algorytmów~\ref{alg:proto_uc_interrupt}~i~\ref{alg:proto_uc_main}.
\begin{algorithm}
\caption{Obsługa protokołu komunikacji, strona mikrokontrolera, przerwanie portu szeregowego}
\label{alg:proto_uc_interrupt}
\begin{algorithmic}[1]
  \REQUIRE \texttt{dane} \ppauza tablica statyczna, do której końca dopisywane są przychodzące dane. Wystarczająco duża na pomieszczenie spodziewanej ilości danych.\\
  \texttt{Serial} \ppauza obiekt klasy obsługującej port szeregowy\\
  \texttt{input, length, commandReady} \ppauza zmienne wykorzystywane do synchronizacji pomiędzy obsługą przerwania, a główną pętlą programu
  \STATE count \textleftarrow{} $0$
  \WHILE{Serial.available()}
    \IF{commandReady == true}
      \STATE continue;
    \ENDIF
    \STATE char \textleftarrow{} Serial.read()
    \STATE dane[count++] \textleftarrow{} char
    \IF{char == '\textbackslash{}r'}
      \STATE length \textleftarrow{} count
      \STATE input \textleftarrow{} dane
      \STATE count \textleftarrow{} $0$
      \STATE commandReady \textleftarrow{} true
    \ENDIF
  \ENDWHILE
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Obsługa protokołu komunikacji, strona mikrokontrolera, główna pętla}
\label{alg:proto_uc_main}
\begin{algorithmic}[1]
  \REQUIRE \texttt{Serial} \ppauza obiekt klasy obsługującej port szeregowy\\
  \texttt{input, length, commandReady} \ppauza zmienne wykorzystywane do synchronizacji pomiędzy obsługą przerwania, a główną pętlą programu\\
  \texttt{toBase64(input, output, inputLength)} \ppauza funkcja zamieniająca ciąg danych \texttt{input} o długości \texttt{inputLength} na kodowanie Base64 i zapisująca wynik do \texttt{output}, zwracająca długość ciągu \texttt{output}\\
  \texttt{handleCommand(input, output)} \ppauza funkcja obsługi komend protokołu, zapisuje ewentualne dane zwrotne w buforze \texttt{output}, zwraca długość zapisanych danych
  \WHILE{true}
    \IF{commandReady == true}
      \STATE resultLength \textleftarrow{} handleCommand(input, commandBuffer)
      \STATE b64Length \textleftarrow{} toBase64(commandBuffer, outputBuffer, resultLength)
      \STATE Serial.write(outputBuffer, b64Length)
      \STATE Serial.write('\textbackslash{}r')
      \STATE commandReady \textleftarrow{} false
    \ENDIF
  \ENDWHILE
\end{algorithmic}
\end{algorithm}
